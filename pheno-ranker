#!/usr/bin/env perl
#
#   A script that ranks individuals against a cohort (BFF)
#
#   Last Modified: Apr/06/2023
#
#   Version 1.0.0
#
#   Copyright (C) 2023 Manuel Rueda - CNAG (manuel.rueda@cnag.crg.eu)
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, see <https://www.gnu.org/licenses/>.
#
#   If this program helps you in your research, please cite.

use strict;
use warnings;
use feature qw(say);
use autodie;
use Getopt::Long qw(:config no_ignore_case);
use Pod::Usage;
use Data::Dumper;
use Path::Tiny;
use JSON::XS;
use YAML::XS qw(LoadFile);
use Sort::Naturally;
use Term::ANSIColor qw(:constants);
use Hash::Fold fold => { array_delimiter => ':' };
use Math::BigInt;

my $debug   = 0;
my $verbose = 0;

##### Main #####
pheno_ranker();
################
exit;

sub pheno_ranker {

    # Defining a few variables
    my $version     = '1.0.0';
    my $output_file = 'matrix.txt';

    # Reading arguments
    GetOptions(
        'reference|r=s' => \my $reference_file,                       # string
        'target|t=s'    => \my $target_file,                          # string
        'weights|w=s'   => \my $weights_file,                         # string
        'o=s'           => \$output_file,                             # string
        'export|e'      => \my $export,                               # flag
        'align|a:s'     => \my $align,                                # opt-string
        'help|?'        => \my $help,                                 # flag
        'man'           => \my $man,                                  # flag
        'debug=i'       => \$debug,                                   # integer
        'verbose|'      => \$verbose,                                 # flag
        'no-color|nc'   => \my $no_color,                             # flag
        'version|V'     => sub { say "$0 Version $version"; exit; }
    ) or pod2usage(2);
    pod2usage(1)                              if $help;
    pod2usage( -verbose => 2, -exitval => 0 ) if $man;
    pod2usage(
        -message => "Please specify a valid reference-cohort for -r\n",
        -exitval => 1
    ) unless $reference_file;

    # Turning color off if argument <--no-color>
    $ENV{'ANSI_COLORS_DISABLED'} = 1 if $no_color;

    # Start printing to STDOUT
    say BOLD CYAN program_header($version), RESET if $verbose;

    # Load JSON files as Perl data structure
    my $ref_data = read_json($reference_file);

    # We assing weights if <--w>
    my $weight =
      ( $weights_file && -f $weights_file ) ? read_yaml($weights_file) : undef;

    # First we create:
    # - $glob_hash => hash with all the cohort keys
    # - $ref_hash  => BIG hash with all individiduals' keys "flattened"
    my ( $glob_hash, $ref_hash ) =
      create_glob_and_ref_hashes( $ref_data, $weight );

    # Second we peform one-hot encoding for each individual
    my $ref_binary_hash =
      create_weigthted_binary_digit_string( $glob_hash, $ref_hash );

    # Hases to be serialized to JSON if <--export>
    my $hash2serialize = {
        glob_hash       => $glob_hash,
        ref_hash        => $ref_hash,
        ref_binary_hash => $ref_binary_hash
    };

    # Perform intra-cohort comparison if <--r>
    intra_cohort_comparison( $ref_binary_hash, $output_file )
      unless $target_file;

    # Perform patient-to-cohort comparison and rank if <--t>
    if ($target_file) {
        my $tar_data        = read_json($target_file);
        my $tar_binary_hash = create_weigthted_binary_digit_string( $glob_hash,
            { $tar_data->{id} => remap_hash( $tar_data, $weight ) } );
        my ( $results_rank, $results_align ) =
          compare_and_rank( $glob_hash, $ref_binary_hash, $tar_binary_hash,
            $weight );

        # Print Rank
        say join "\n", @$results_rank;

        # Write JSON for align
        write_json(
            {
                filepath => ( $align ? $align : 'align.json' ),
                data     => $results_align
            }
        ) if defined $align;

        # Load $tar_binary_hash if <--e}
        $hash2serialize->{tar_binary_hash} = $tar_binary_hash if $export;
    }

    # Dump to JSON if <--export>
    serialize_hashes($hash2serialize) if $export;
}

sub serialize_hashes {

    my $arg = shift;
    write_json( { data => $arg->{$_}, filepath => qq/$_.json/ } )
      for keys %{$arg};
    return 1;
}

sub write_json {

    my $arg       = shift;
    my $file      = $arg->{filepath};
    my $json_data = $arg->{data};
    my $json      = JSON::XS->new->utf8->canonical->pretty->encode($json_data);
    path($file)->spew_utf8($json);
    return 1;
}

sub intra_cohort_comparison {

    my ( $ref_binary_hash, $output ) = @_;
    my @sorted_keys_ref_binary_hash = nsort( keys %{$ref_binary_hash} );

    say "Performing INTRA-COHORT compariSon" if ( $debug || $verbose );

    # Print to  $output
    open( my $fh, ">", $output );
    say $fh "\t", join "\t", @sorted_keys_ref_binary_hash;

    # NB: It's a symmetric matrix so we could just compute
    #     triangle. However,  R needs the whole matrix
    #     Hammind distance is very fast, but
    #     I will re-implement if time becomes a bottleneck

    # I elements
    for my $i (@sorted_keys_ref_binary_hash) {
        say "Calculating <$i> against the cohort..." if $verbose;
        my $str1 = $ref_binary_hash->{$i};
        print $fh "$i\t";

        # J elements
        for my $j (@sorted_keys_ref_binary_hash) {
            my $str2 = $ref_binary_hash->{$j};
            print $fh hd_fast( $str1, $str2 ), "\t";
        }
        print $fh "\n";
    }
    close $fh;
    say "Matrix saved to <$output>" if ( $debug || $verbose );
    return 1;
}

sub compare_and_rank {

    my ( $glob_hash, $ref_binary_hash, $tar_binary_hash, $weight ) = @_;
    say "Performing PATIENT-COHORT comparison" if ( $debug || $verbose );

    my $distance_str = $weight ? 'wDistance' : 'Distance';
    my %out;
    my ($tmp) = keys %{$tar_binary_hash};
    my $str2 = $tar_binary_hash->{$tmp};
    for my $key ( keys %{$ref_binary_hash} ) {    # No need to sort
        my $str1 = $ref_binary_hash->{$key};
        say "STR1:$str1" if $debug;
        say "STR2:$str2\n" if $debug;
        $out{$key} = hd_fast( $str1, $str2 );
    }

    # Sort by value and load results
    my @results;
    my %info;
    for my $key ( sort { $out{$a} <=> $out{$b} } keys %out ) {

        # Add distance
        my $tmp_str = qq/$distance_str(id:$key) = $out{$key}/;
        push @results, $tmp_str;

        my $alignment =
          create_alignment( $ref_binary_hash->{$key}, $str2, $glob_hash );
        say "$tmp_str\n$$alignment" if $debug;

        # Add alignment
        $info{$key} = {
            type                    => $distance_str,
            distance                => $out{$key},
            reference_binary_string => $ref_binary_hash->{$key},
            target_binary_string    => $str2,
            alignment               => $$alignment
        };

        # Add ASCII

    }
    return \@results, \%info;
}

sub create_alignment {

    my ( $binary_string1, $binary_string2, $glob_hash ) = @_;

    my $length1 = length($binary_string1);
    my $length2 = length($binary_string2);

    die "The binary strings must have the same length"
      if ( $length1 != $length2 );

    my $recreated_array = recreate_array($glob_hash);

    #say "$length1, $length2, ", scalar @$recreated_array;

    my $out          = '';
    my $cum_distance = 0;
    for ( my $i = 0 ; $i < $length1 ; $i++ ) {
        my $char1 = substr( $binary_string1, $i, 1 );
        my $char2 = substr( $binary_string2, $i, 1 );
        my $key   = $recreated_array->[$i];
        my $val   = sprintf( "%3d", $glob_hash->{$key} );
        $i = $i + $glob_hash->{$key} - 1;
        $cum_distance += $glob_hash->{$key} if $char1 ne $char2;
        my $cum_d_pretty = sprintf( "%3d", $cum_distance );
        my $distance     = $char1 eq $char2 ? 0 : $glob_hash->{$key};
        $distance = sprintf( "%3d", $distance );

        # We need a hash for this
        $out .=
          ( $char1 eq '1' && $char2 eq '1' )
          ? qq/$char1 ----- $char2 | (w:$val|d:$distance|cd:$cum_d_pretty|) $key\n/
          : ( $char1 eq '0' && $char2 eq '1' )
          ? qq/$char1 xxx-- $char2 | (w:$val|d:$distance|cd:$cum_d_pretty|) $key\n/
          : ( $char1 eq '1' && $char2 eq '0' )
          ? qq/$char1 --xxx $char2 | (w:$val|d:$distance|cd:$cum_d_pretty|) $key\n/
          : qq/$char1       $char2 | (w:$val|d:$distance|cd:$cum_d_pretty|) $key\n/;
    }
    return \$out;
}

sub recreate_array {

    my $glob_hash             = shift;
    my @sorted_keys_glob_hash = nsort( keys %{$glob_hash} );
    my @recreated_array;

    foreach my $key (@sorted_keys_glob_hash) {
        for ( my $i = 0 ; $i < $glob_hash->{$key} ; $i++ ) {
            push @recreated_array, $key;
        }
    }
    return \@recreated_array;

}

sub create_glob_and_ref_hashes {

    my ( $array, $weight ) = @_;
    my $glob_hash = {};
    my $ref_hash_flattened;

    for my $i ( @{$array} ) {
        my $id = $i->{id};
        say "Flattening and remapping $id..." if $verbose;
        my $ref_hash = remap_hash( $i, $weight );
        $ref_hash_flattened->{$id} = $ref_hash;

        # The idea is to create a $glob_hash with unique key-values
        $glob_hash = { %$glob_hash, %$ref_hash };
    }
    return ( $glob_hash, $ref_hash_flattened );
}

sub discard_excluded_phenotypicFeatures {

    my $hash = shift;
    if ( exists $hash->{phenotypicFeatures} ) {
        map { $_ = $_->{excluded} ? undef : $_ }
          @{ $hash->{phenotypicFeatures} };
    }
    return $hash;
}

sub remap_hash {

    my ( $hash, $weight ) = @_;
    my $out_hash;

    # Do some cleaning first
    $hash = fold( discard_excluded_phenotypicFeatures($hash) );

    for my $key ( keys %{$hash} ) {

        # To see which ones were discarded
        #say $key if !defined $hash->{$key};

        # Discard undefined
        next unless defined $hash->{$key};

        # Discarding lines with 'low quality' keys (Time profiled with :NYTProf: ms time)
        next
          if $key =~
m/info|notes|label|value|\.high|\.low|metaData|familyHistory|excluded/;
        my $val = $hash->{$key};

        # Discarding lines with val (Time profiled with :NYTProf: ms time)
        next
          if ( $val eq 'NA'
            || $val eq 'Fake'
            || $val =~ m/1900-01-01|NA0000|P999Y|P9999Y|ARRAY|phenopacket_id/ );

        # Getting rid of the index for (measures|treatments|exposures|phenotypicMeasure):\d+
        # measures:0.foo.bar
        # exposures:1.baz.foo
        # *** IMPORTANT ****
        # - By removing the element, we also lose the provenance of each nested value,
        #   e.g., "diseases.ageOfOnset.age.iso8601duration.72Y"
        #   but this is a compromise that we have to make to encode the data correctly!!!
        # - We are keeping the ^id. so this means we will have at least ONE match
        $key =~ s/:(\d+)\././;
        my $tmp = $key . '.' . $val;

        # Assign weight
        # NB: mrueda (04-12-23) - it's ok if $weight == undef => NO AUTOVIVIFICATION!
        $out_hash->{$tmp} = exists $weight->{$tmp} ? $weight->{$tmp} : 1;
    }
    return $out_hash;
}

sub create_weigthted_binary_digit_string {

    my ( $glob_hash, $cmp_hash ) = @_;
    my $out_hash;

    # *** IMPORTANT ***
    # Being a nested for, keys %{$glob_hash} does need sorting
    # BUT, we sort to follow the same order as serialized (sorted)
    my @sorted_keys_glob_hash = nsort( keys %{$glob_hash} );

    # IDs of each indidividual
    for my $key1 ( keys %{$cmp_hash} ) {    # no need to sort

        # One-hot encoding = Representing categorical data as numerical
        my $binary_str = '';
        for my $key2 (@sorted_keys_glob_hash) {

            my $ones  = (1) x $glob_hash->{$key2};
            my $zeros = (0) x $glob_hash->{$key2};
            $binary_str .= exists $cmp_hash->{$key1}{$key2} ? $ones : $zeros;
        }
        $out_hash->{$key1} = $binary_str;
    }
    return $out_hash;
}

sub read_json {

    my $str = path(shift)->slurp_utf8;
    return decode_json($str);    # Decode to Perl data structure
}

sub read_yaml {

    return LoadFile(shift);      # Decode to Perl data structure
}

sub hd_fast {

    # Hamming Distance
    return ( $_[0] ^ $_[1] ) =~ tr/\001-\255//;
}

sub program_header {

    my $version = shift;
    my $str     = <<EOF;
****************************************
*    Rank against cohort (BFF/PXF)     *
*          - PHENO-RANKER -            *
*          Version: $version            *
*      (C) 2023 Manuel Rueda, PhD      *
*    GNU General Public License v3     *
****************************************
EOF
    return $str;
}

=head1 NAME

pheno-ranker: A script that compares a given BFF/PXF file against a BFF/PXF cohort

=head1 SYNOPSIS


pheno-ranker -r <individuals.json> -t <patient.json> [-options]

     Arguments:                       
       -r|reference-file              BFF/PXF file (JSON array)
       -t|target-file                 BFF/PXF file (JSON)

     Options:
       -o                             Output file [matrix.txt]
       -w|weights                     YAML file with weights
       -debug                         Print debugging (from 1 to 5, being 5 max)
       -e|export                      Export miscellaena JSON files
       -h|help                        Brief help message
       -man                           Full documentation
       -nc|-no-color                  Don't print colors to STDOUT
       -v|verbose                     Verbosity on
       -V|version                     Print version

=head1 DESCRIPTION

pheno-ranker: A script that compares a given BFF/PXF file against a BFF/PXF cohort

=head1 SUMMARY

pheno-ranker: A script that compares and ranks (by dissimilarity) a given BFF/PXF file against a BFF/PXF cohort

=head1 INSTALLATION

 $ cpanm sudo --installdeps .

=head3 System requirements

  * Ideally a Debian-based distribution (Ubuntu or Mint), but any other (e.g., CentOs, OpenSuse) should do as well.
  * Perl 5 (>= 5.10 core; installed by default in most Linux distributions). Check the version with "perl -v"
  * 500MB of RAM.
  * 1 core (it only uses one core per job).
  * At least 1GB HDD.

=head1 HOW TO RUN PHENO-RANKER

For executing pheno-ranker you will need:

=over

=item Input file(s):
      
A PXF or BFF file(s) in JSON format. The reference cohort must be a JSON array, where each individual data are consolidated in one object. 

If no C<--t> argument is provided then it will compute intra-cohort comparison only. If C<--t> argument is provided then the target JSON will be compared against the C<-r> reference cohort.

=back

B<Examples:>

 $ ./pheno-ranker -r phenopackets.json  # intra-cohort

 $ ./pheno-ranker -r phenopackets.json -o my_matrix.txt # intra-cohort

 $ ./pheno-ranker -r phenopackets.json -w weights.yaml  # intra-cohort with weights

 $ $path/pheno-ranker -t patient.json -r individuals.json # patient-cohort

=head2 COMMON ERRORS AND SOLUTIONS

 * Error message: Foo
   Solution: Bar

 * Error message: Foo
   Solution: Bar

=head1 AUTHOR 

Written by Manuel Rueda, PhD. Info about CNAG can be found at L<https://www.cnag.crg.eu>.

=head1 COPYRIGHT AND LICENSE

This PERL file is copyrighted. See the LICENSE file included in this distribution.

=cut
